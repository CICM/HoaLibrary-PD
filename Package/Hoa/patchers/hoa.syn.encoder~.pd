#N canvas 65 219 771 461 10;
#X obj 94 411 hoa.out~;
#X obj 12 5 c.loadmess;
#X text 68 303 Receive the signal;
#X text 70 433 Output the signal;
#X obj 94 369 *~;
#X obj 195 329 line~;
#X msg 195 307 \$1 20;
#X obj 94 325 hoa.in~ extra 1;
#X obj 12 52 hoa.thisprocess~;
#X obj 195 191 *;
#X obj 300 228 < 0;
#X obj 195 248 spigot 0;
#X obj 255 248 spigot 0;
#X obj 195 274 cos;
#X obj 240 228 >= 0;
#X obj 255 274 sin;
#X text 193 81 Extra 1 Receive the azimuth (in radian).;
#N canvas 0 50 450 300 print.domain.error 0;
#X obj 6 54 hoa.mode.sel;
#X obj 6 133 sel 0;
#X obj 7 214 print hoa.syn.encoder~;
#X msg 7 163 only valid in the circular harmonics domain.;
#X obj 6 24 inlet;
#X connect 0 0 1 0;
#X connect 1 1 3 0;
#X connect 3 0 2 0;
#X connect 4 0 0 0;
#X restore 43 88 pd print.domain.error;
#X text 260 335 If index of the harmonic >= 0 \, the signal is multiplied
by cos(azimuth * index of the harmonic) else \, the signal is multiplied
by sin(azimuth * abs(index of the harmonic)).;
#X text 239 15 This hoa.processing shows what performs the encoding
of a signal in the circular harmonics domain.;
#X obj 195 111 hoa.in extra 2;
#X msg 195 147 0;
#X obj 12 110 unpack 0 0 0;
#X connect 1 0 8 0;
#X connect 4 0 0 0;
#X connect 5 0 4 1;
#X connect 6 0 5 0;
#X connect 7 0 4 0;
#X connect 8 0 22 0;
#X connect 8 1 17 0;
#X connect 8 3 21 0;
#X connect 9 0 11 0;
#X connect 9 0 12 0;
#X connect 10 0 12 1;
#X connect 11 0 13 0;
#X connect 12 0 15 0;
#X connect 13 0 6 0;
#X connect 14 0 11 1;
#X connect 15 0 6 0;
#X connect 20 0 9 0;
#X connect 21 0 9 0;
#X connect 22 1 9 1;
#X connect 22 2 14 0;
#X connect 22 2 10 0;
